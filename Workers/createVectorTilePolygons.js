define(["./AttributeCompression-e18a879a","./Matrix3-b6f074fa","./Color-27beebda","./defaultValue-0a909f67","./IndexDatatype-2149f06c","./Math-e97915da","./OrientedBoundingBox-e3f4d571","./Matrix2-163b5a1d","./createTaskProcessorWorker","./ComponentDatatype-77274976","./WebGLConstants-a8cc3e8c","./Transforms-713aa3a8","./combine-ca22a614","./RuntimeError-06c93819","./EllipsoidTangentPlane-8eee3c2f","./AxisAlignedBoundingBox-c7183545","./IntersectionTests-87baf287","./Plane-1c5a21a3"],(function(e,t,n,a,r,o,i,s,c,f,d,l,u,h,g,p,b,m){"use strict";const y=new t.Cartesian3,C=new t.Ellipsoid,I=new s.Rectangle,x={min:void 0,max:void 0,indexBytesPerElement:void 0};const w=new t.Cartesian3,A=new t.Cartesian3,E=new t.Cartesian3,N=new t.Cartesian3,T=new t.Cartesian3,B=new t.Cartographic,k=new s.Rectangle;return c((function(c,f){let d;!function(e){const n=new Float64Array(e);let a=0;x.indexBytesPerElement=n[a++],x.min=n[a++],x.max=n[a++],t.Cartesian3.unpack(n,a,y),a+=t.Cartesian3.packedLength,t.Ellipsoid.unpack(n,a,C),a+=t.Ellipsoid.packedLength,s.Rectangle.unpack(n,a,I)}(c.packedBuffer),d=2===x.indexBytesPerElement?new Uint16Array(c.indices):new Uint32Array(c.indices);const l=new Uint16Array(c.positions),u=new Uint32Array(c.counts),h=new Uint32Array(c.indexCounts),g=new Uint32Array(c.batchIds),p=new Uint32Array(c.batchTableColors),b=new Array(u.length),m=y,L=C;let O=I;const U=x.min,P=x.max;let F,M,S,D=c.minimumHeights,R=c.maximumHeights;a.defined(D)&&a.defined(R)&&(D=new Float32Array(D),R=new Float32Array(R));const _=l.length/2,G=l.subarray(0,_),V=l.subarray(_,2*_);e.AttributeCompression.zigZagDeltaDecode(G,V);const Y=new Float64Array(3*_);for(F=0;F<_;++F){const e=G[F],n=V[F],a=o.CesiumMath.lerp(O.west,O.east,e/32767),r=o.CesiumMath.lerp(O.south,O.north,n/32767),i=t.Cartographic.fromRadians(a,r,0,B),s=L.cartographicToCartesian(i,w);t.Cartesian3.pack(s,Y,3*F)}const v=u.length,H=new Array(v),W=new Array(v);let z=0,Z=0;for(F=0;F<v;++F)H[F]=z,W[F]=Z,z+=u[F],Z+=h[F];const j=new Float32Array(3*_*2),q=new Uint16Array(2*_),J=new Uint32Array(W.length),K=new Uint32Array(h.length);let Q=[];const X={};for(F=0;F<v;++F)S=p[F],a.defined(X[S])?(X[S].positionLength+=u[F],X[S].indexLength+=h[F],X[S].batchIds.push(F)):X[S]={positionLength:u[F],indexLength:h[F],offset:0,indexOffset:0,batchIds:[F]};let $,ee=0,te=0;for(S in X)if(X.hasOwnProperty(S)){$=X[S],$.offset=ee,$.indexOffset=te;const e=2*$.positionLength,t=2*$.indexLength+6*$.positionLength;ee+=e,te+=t,$.indexLength=t}const ne=[];for(S in X)X.hasOwnProperty(S)&&($=X[S],ne.push({color:n.Color.fromRgba(parseInt(S)),offset:$.indexOffset,count:$.indexLength,batchIds:$.batchIds}));for(F=0;F<v;++F){S=p[F],$=X[S];const e=$.offset;let n=3*e,r=e;const o=H[F],s=u[F],c=g[F];let f=U,l=P;a.defined(D)&&a.defined(R)&&(f=D[F],l=R[F]);let y=Number.POSITIVE_INFINITY,C=Number.NEGATIVE_INFINITY,I=Number.POSITIVE_INFINITY,x=Number.NEGATIVE_INFINITY;for(M=0;M<s;++M){const e=t.Cartesian3.unpack(Y,3*o+3*M,w);L.scaleToGeodeticSurface(e,e);const a=L.cartesianToCartographic(e,B),i=a.latitude,s=a.longitude;y=Math.min(i,y),C=Math.max(i,C),I=Math.min(s,I),x=Math.max(s,x);const d=L.geodeticSurfaceNormal(e,A);let u=t.Cartesian3.multiplyByScalar(d,f,E);const h=t.Cartesian3.add(e,u,N);u=t.Cartesian3.multiplyByScalar(d,l,u);const g=t.Cartesian3.add(e,u,T);t.Cartesian3.subtract(g,m,g),t.Cartesian3.subtract(h,m,h),t.Cartesian3.pack(g,j,n),t.Cartesian3.pack(h,j,n+3),q[r]=c,q[r+1]=c,n+=6,r+=2}O=k,O.west=I,O.east=x,O.south=y,O.north=C,b[F]=i.OrientedBoundingBox.fromRectangle(O,U,P,L);let _=$.indexOffset;const G=W[F],V=h[F];for(J[F]=_,M=0;M<V;M+=3){const t=d[G+M]-o,n=d[G+M+1]-o,a=d[G+M+2]-o;Q[_++]=2*t+e,Q[_++]=2*n+e,Q[_++]=2*a+e,Q[_++]=2*a+1+e,Q[_++]=2*n+1+e,Q[_++]=2*t+1+e}for(M=0;M<s;++M){const t=M,n=(M+1)%s;Q[_++]=2*t+1+e,Q[_++]=2*n+e,Q[_++]=2*t+e,Q[_++]=2*t+1+e,Q[_++]=2*n+1+e,Q[_++]=2*n+e}$.offset+=2*s,$.indexOffset=_,K[F]=_-J[F]}Q=r.IndexDatatype.createTypedArray(j.length/3,Q);const ae=ne.length;for(let e=0;e<ae;++e){const t=ne[e].batchIds;let n=0;const a=t.length;for(let e=0;e<a;++e)n+=K[t[e]];ne[e].count=n}const re=function(e,t,a){const r=t.length,o=2+r*i.OrientedBoundingBox.packedLength+1+function(e){const t=e.length;let a=0;for(let r=0;r<t;++r)a+=n.Color.packedLength+3+e[r].batchIds.length;return a}(a),s=new Float64Array(o);let c=0;s[c++]=e,s[c++]=r;for(let n=0;n<r;++n)i.OrientedBoundingBox.pack(t[n],s,c),c+=i.OrientedBoundingBox.packedLength;const f=a.length;s[c++]=f;for(let i=0;i<f;++i){const e=a[i];n.Color.pack(e.color,s,c),c+=n.Color.packedLength,s[c++]=e.offset,s[c++]=e.count;const t=e.batchIds,r=t.length;s[c++]=r;for(let n=0;n<r;++n)s[c++]=t[n]}return s}(2===Q.BYTES_PER_ELEMENT?r.IndexDatatype.UNSIGNED_SHORT:r.IndexDatatype.UNSIGNED_INT,b,ne);return f.push(j.buffer,Q.buffer,J.buffer,K.buffer,q.buffer,re.buffer),{positions:j.buffer,indices:Q.buffer,indexOffsets:J.buffer,indexCounts:K.buffer,batchIds:q.buffer,packedBuffer:re.buffer}}))}));